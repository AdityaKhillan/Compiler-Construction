%define api.value.type { ParserValue }

%code requires {
    #include <iostream>
    #include <vector>
    #include <string>
    #include <unordered_map>
    #include "parser_util.hh"
    #include "symbol.hh"
}

%code {

#include <cstdlib>

extern int yylex();
extern int yyparse();

extern struct NodeStmts* final_values;


std::unordered_map<std::string, struct NodeStmts*> function_param_list;

struct ScopeTreeNode{
    struct SymbolTable symbol_table;
    struct ScopeTreeNode* parentScope;
    ScopeTreeNode(){};
    ScopeTreeNode(ScopeTreeNode* parentScope){
        this->parentScope=parentScope;
    };

};

struct ScopeTreeNode* current_scope=new ScopeTreeNode(nullptr);
// current_scope->parentScope=nullptr;

int yyerror(std::string msg);

}

/* %union {
    int ival;
    short sval;
    long lval;
} */

/* declaring token*/
%token TPLUS TDASH TSTAR TSLASH TFUN TCOMMA
%token <lexeme> TINT_LIT TIDENT DTYPE
%token INT TLET TDBG
%token TSCOL TLPAREN TRPAREN TEQUAL
%token TQUESTMARK TCOLON
%token SHORT LONG
%token TIF TELSE TLBRACE TRBRACE
%token TLESS TGREAT TNEQUAL

%type <node> Expr Stmt Scope ScopeStart ScopeEnd Param FuncScope Funct
%type <stmts> Program StmtList ParamList
%type <intlit> Lit
//%type <listTypes>

/* %type <ival> int_var_declaration
%type <sval> short_var_declaration
%type <lval> long_var_declaration
/* %type <ival> int_expr */
/* %type <sval> short_expr
%type <lval> long_expr */ 

%left TCOLON
%left TQUESTMARK
%left TPLUS TDASH
%left TSTAR TSLASH
%%
/* The rule has two possible productions, separated by the | character. */
Program :                
        { final_values = nullptr; }  // first production rule : It is executed when the parser encounters an empty input, which is represented by the empty rule Îµ.
        | StmtList// StmtList: This is a non-terminal symbol that represents a sequence of statements. The parser will execute the productions for StmtList to generate a list of statements, which will be represented by the $1 symbol in the semantic action.

        // TSCOL: This is a token symbol that represents a semicolon. The parser expects the input to end with a semicolon after the StmtList.
        { final_values = $1; $$=$1;}
        // This is the semantic action that will be executed after the StmtList and TSCOL are recognized. It assigns the value of $1, which is the list of statements generated by the StmtList productions, to the final_values variable.
        ;

StmtList : Stmt            
         { $$ = new NodeStmts(); $$->push_back($1); }
         | StmtList  Stmt 
         { $$->push_back($2);}
         ;

Stmt :  Funct
        |Scope
        |TLET TIDENT TCOLON DTYPE TEQUAL Expr TSCOL
     {
           if(current_scope->symbol_table.contains($2)) {
         // tried to redeclare variable, so error
            yyerror("tried to redeclare variable.\n");
        } 
        else {
            current_scope->symbol_table.insert($2);
            // std::cout << $4 << std::endl; 
            $$ = new NodeAssn($2, $6, $4);
        }
     }
     | TIDENT TEQUAL Expr TSCOL
     {
        int contains;
        struct ScopeTreeNode* temp=current_scope;
        while(current_scope!=nullptr){
            if(current_scope->symbol_table.contains($1) != 0) {
            // error
                break;
            } 
            current_scope=current_scope->parentScope;

        }
        if (!current_scope){
            yyerror("Variable is not declared.\n");
        }
        else {
            // symbol_table.insert($1);

            $$ = new NodeAssign($1, $3);
        }
        current_scope=temp;
     }
     | TDBG Expr TSCOL
     { 
        $$ = new NodeDebug($2);
     }
     | TIF Expr Scope TELSE Scope     {std::cout << "hello" << std::endl;
        $$ = new NodeIf($2, $3, $5);
     }
     | TIF Lit Scope TELSE Scope {
        if($2->value != 0) {
            $$ = $3;
        }
        else {
            $$ = $5;
        }
     }
     ;

/* if_else_stmt : TIF Expr TLBRACE Expr TRBRACE TELSE TLBRACE Expr TRBRACE
            {std::cout << "hello" << std::endl;
            $$ = new NodeIf($2, $4, $8);} */

/* Dtype : INT
      {}
      | SHORT
      {}
      | LONG
      {}
      ; */

Expr : Lit             
     { $$ = $1; }
     | TIDENT
     { 
        int contains;
        struct ScopeTreeNode* temp=current_scope;
        while(current_scope!=nullptr){
            if(current_scope->symbol_table.contains($1)) {
            // error
                break;
            } 
            current_scope=current_scope->parentScope;

        }
        if (!current_scope){
            yyerror("using undeclared variable.\n");

        }
        else {
            // symbol_table.insert($1);
            $$ = new NodeIdent($1); 
        }
        current_scope=temp;
     }
     
     | Expr TPLUS Expr
     { $$ = new NodeBinOp(NodeBinOp::PLUS, $1, $3); }
     | Expr TDASH Expr
     { $$ = new NodeBinOp(NodeBinOp::MINUS, $1, $3); }
     | Expr TSTAR Expr
     { $$ = new NodeBinOp(NodeBinOp::MULT, $1, $3); }
     | Expr TSLASH Expr
     { $$ = new NodeBinOp(NodeBinOp::DIV, $1, $3); }
     | TLPAREN Expr TRPAREN 
     { $$ = $2; }
     | Expr TQUESTMARK Expr TCOLON Expr
     { $$ = new NodeTernaryOp(NodeTernaryOp::QMARK, $1, $3, $5); }
     /* | comparator
     { $$ = $1;} */
     ;

Lit: TINT_LIT
    { $$ =new NodeInt(stoi($1)); }
    | Lit TPLUS Lit
    { $$ = new NodeInt($1->value + $3->value); }    
    | Lit TDASH Lit
    { $$ = new NodeInt($1->value - $3->value); }    
    | Lit TSTAR Lit
    { $$ = new NodeInt($1->value * $3->value); }    
    | Lit TSLASH Lit
    { $$ = new NodeInt($1->value / $3->value); }    
    ;

Scope: ScopeStart Program ScopeEnd
    {
        $$ = new NodeScope($2);
    };
ScopeStart: TLBRACE
    {
        struct ScopeTreeNode* new_scope=new ScopeTreeNode();
        new_scope->parentScope=current_scope;
        current_scope=new_scope;
    };
ScopeEnd : TRBRACE  
    {
        current_scope=current_scope->parentScope;
    };
/* comparator : Expr TEQUAL Expr
           {$$ = new NodeBinOp(NodeBinOp::EQ, $1, $3);}
           | Expr TLESS Expr
           {$$ = new NodeBinOp(NodeBinOp::LT, $1, $3);}
           | Expr TGREAT Expr
           {$$ = new NodeBinOp(NodeBinOp::GT, $1, $3);}
           | Expr TNEQUAL Expr
           {$$ = new NodeBinOp(NodeBinOp::NEQ, $1, $3);}
           ; */

FuncScope: TFUN
        {   std::cout<<"Started Function"<<std::endl;
            struct ScopeTreeNode* new_scope=new ScopeTreeNode();
            new_scope->parentScope=current_scope;
            current_scope=new_scope;};

Funct: FuncScope TIDENT TLPAREN ParamList TRPAREN TCOLON DTYPE TLBRACE Program ScopeEnd
        {
            std::cout<<"Functing"<<std::endl;

            if (function_param_list.find($2)!=function_param_list.end()){
                yyerror("Redeclaring Function!!\n");
            }
            std::cout<<$2<<std::endl;
            function_param_list.insert({$2, $4});
            // function_param_list[$2] = $4;
            std::cout << "hello error" << std::endl; 
            $$ = new FunctNode($2,$4,$9,$7);
        }

ParamList: {$$=new NodeStmts();}
        |   
        Param
        {
            std::cout<<"first listing"<<std::endl;
            $$=new NodeStmts();
            $$->push_back($1);
        }
        |
         ParamList TCOMMA Param{
            std::cout<<"listing"<<std::endl;
            $$->push_back($3);
        };
Param: TIDENT TCOLON DTYPE
    {
        std::cout<<"paraming"<<std::endl;
        Node* a=new NodeInt(0);
        $$ = new NodeAssn($1,a,$3);
    };


%%

int yyerror(std::string msg) {
    std::cerr << "Error! " << msg << std::endl;
    exit(1);
}